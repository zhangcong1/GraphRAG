/**
 * Áã¨Á´ãÊµãËØïÂêëÈáèÂåñÂäüËÉΩÔºà‰∏ç‰æùËµñ VS CodeÔºâ
 */
const fs = require('fs');
const path = require('path');

// Ê®°ÊãüÂêëÈáèÊï∞ÊçÆÂ∫ìÁ±ªÔºàÁÆÄÂåñÁâàÔºâ
class SimpleVectorDB {
    constructor(projectPath) {
        this.projectName = path.basename(projectPath);
        this.dbFilePath = path.join(projectPath, '.huima', 'test-vector-db.json');
        this.data = this.loadDatabase();
    }

    loadDatabase() {
        try {
            if (fs.existsSync(this.dbFilePath)) {
                const data = fs.readFileSync(this.dbFilePath, 'utf8');
                return JSON.parse(data);
            }
        } catch (error) {
            console.warn('Êï∞ÊçÆÂ∫ìÂä†ËΩΩÂ§±Ë¥•ÔºåÂàõÂª∫Êñ∞Êï∞ÊçÆÂ∫ì');
        }
        return { collections: {} };
    }

    saveDatabase() {
        try {
            const dir = path.dirname(this.dbFilePath);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(this.dbFilePath, JSON.stringify(this.data, null, 2));
            console.log(`‚úÖ Êï∞ÊçÆÂ∫ìÂ∑≤‰øùÂ≠ò: ${this.dbFilePath}`);
        } catch (error) {
            console.error('‚ùå ‰øùÂ≠òÊï∞ÊçÆÂ∫ìÂ§±Ë¥•:', error);
        }
    }

    createCollection(name, dimension) {
        if (!this.data.collections[name]) {
            this.data.collections[name] = {
                dimension: dimension,
                documents: [],
                createdAt: new Date().toISOString()
            };
            console.log(`‚úÖ ÈõÜÂêà "${name}" ÂàõÂª∫ÊàêÂäüÔºåÁª¥Â∫¶: ${dimension}`);
        }
        this.saveDatabase();
    }

    insert(collectionName, documents) {
        if (!this.data.collections[collectionName]) {
            throw new Error(`ÈõÜÂêà "${collectionName}" ‰∏çÂ≠òÂú®`);
        }

        const collection = this.data.collections[collectionName];
        
        documents.forEach(doc => {
            if (doc.vector.length !== collection.dimension) {
                throw new Error(`ÂêëÈáèÁª¥Â∫¶‰∏çÂåπÈÖç`);
            }
            collection.documents.push(doc);
        });

        console.log(`‚úÖ ÊàêÂäüÊèíÂÖ• ${documents.length} ‰∏™ÊñáÊ°£`);
        this.saveDatabase();
    }

    search(collectionName, queryVector, options = {}) {
        const { topK = 5 } = options;
        
        if (!this.data.collections[collectionName]) {
            throw new Error(`ÈõÜÂêà "${collectionName}" ‰∏çÂ≠òÂú®`);
        }

        const collection = this.data.collections[collectionName];
        
        const results = collection.documents.map(doc => {
            const similarity = this.cosineSimilarity(queryVector, doc.vector);
            return { document: doc, score: similarity };
        });

        return results
            .sort((a, b) => b.score - a.score)
            .slice(0, topK);
    }

    cosineSimilarity(vecA, vecB) {
        let dotProduct = 0;
        let magnitudeA = 0;
        let magnitudeB = 0;

        for (let i = 0; i < vecA.length; i++) {
            dotProduct += vecA[i] * vecB[i];
            magnitudeA += vecA[i] * vecA[i];
            magnitudeB += vecB[i] * vecB[i];
        }

        magnitudeA = Math.sqrt(magnitudeA);
        magnitudeB = Math.sqrt(magnitudeB);

        if (magnitudeA === 0 || magnitudeB === 0) {
            return 0;
        }

        return dotProduct / (magnitudeA * magnitudeB);
    }

    getStats() {
        const stats = {
            totalCollections: Object.keys(this.data.collections).length,
            totalDocuments: 0,
            collections: {}
        };

        Object.entries(this.data.collections).forEach(([name, collection]) => {
            stats.collections[name] = {
                documents: collection.documents.length,
                dimension: collection.dimension
            };
            stats.totalDocuments += collection.documents.length;
        });

        return stats;
    }
}

// Ê®°Êãü Embedding ÊúçÂä°
class SimpleEmbeddingService {
    constructor() {
        this.dimension = 128;
    }

    async getEmbeddings(texts) {
        console.log(`üîÑ Ê≠£Âú®ÁîüÊàê ${texts.length} ‰∏™ÊñáÊú¨ÁöÑÊ®°ÊãüÂêëÈáè...`);
        
        return texts.map((text, index) => {
            const seed = this.hashString(text + index.toString());
            const random = this.seededRandom(seed);
            return Array(this.dimension).fill(0).map(() => random() * 2 - 1);
        });
    }

    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }

    seededRandom(seed) {
        let current = seed;
        return () => {
            current = (current * 9301 + 49297) % 233280;
            return current / 233280;
        };
    }
}

/**
 * ÊµãËØïÂêëÈáèÂåñÂäüËÉΩ
 */
async function testVectorization() {
    console.log('üß™ ÂºÄÂßãÊµãËØïÂêëÈáèÂåñÂäüËÉΩ...\n');

    const projectPath = __dirname;
    
    try {
        // 1. ÊµãËØï Embedding ÊúçÂä°
        console.log('üì° ÊµãËØï Embedding ÊúçÂä°...');
        const embeddingService = new SimpleEmbeddingService();

        const testTexts = [
            'Áî®Êà∑ËÆ§ËØÅÂíåÊéàÊùÉÂäüËÉΩÔºåÂåÖÊã¨ÁôªÂΩï„ÄÅÊ≥®ÂÜå„ÄÅÊùÉÈôêÈ™åËØÅ',
            'Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåÊü•ËØ¢Êìç‰ΩúÔºåÊîØÊåÅÂ¢ûÂà†ÊîπÊü•',
            'APIÊé•Âè£ÂÆö‰πâÔºåÂåÖÊã¨RESTfulÊé•Âè£ÂíåGraphQL',
            'ÂâçÁ´ØÁªÑ‰ª∂Ê∏≤ÊüìÔºåVueÁªÑ‰ª∂ÂíåReactÁªÑ‰ª∂'
        ];

        console.log('ÊµãËØïÊñáÊú¨:');
        testTexts.forEach((text, index) => {
            console.log(`${index + 1}. ${text}`);
        });
        
        const embeddings = await embeddingService.getEmbeddings(testTexts);
        console.log(`‚úÖ ÊàêÂäüÁîüÊàê ${embeddings.length} ‰∏™ÂêëÈáèÔºåÁª¥Â∫¶: ${embeddings[0].length}\n`);

        // 2. ÊµãËØïÂêëÈáèÊï∞ÊçÆÂ∫ì
        console.log('üíæ ÊµãËØïÂêëÈáèÊï∞ÊçÆÂ∫ì...');
        const vectorDB = new SimpleVectorDB(projectPath);
        
        const collectionName = 'test_knowledge_graph';
        const dimension = embeddings[0].length;
        
        vectorDB.createCollection(collectionName, dimension);
        
        // ÂáÜÂ§áÁü•ËØÜÂõæË∞±ÊñáÊ°£
        const documents = testTexts.map((text, index) => ({
            id: `kg_node_${index + 1}`,
            vector: embeddings[index],
            content: text,
            metadata: {
                nodeId: `node_${index + 1}`,
                elementType: ['function', 'class', 'interface', 'component'][index],
                fileName: ['auth.js', 'database.js', 'api.js', 'components.vue'][index],
                filePath: `/src/${['auth.js', 'database.js', 'api.js', 'components.vue'][index]}`,
                semanticTags: [
                    ['authentication', 'security', 'user'],
                    ['database', 'query', 'data'],
                    ['api', 'rest', 'interface'],
                    ['frontend', 'component', 'ui']
                ][index],
                vectorizedAt: new Date().toISOString()
            }
        }));
        
        vectorDB.insert(collectionName, documents);
        console.log();

        // 3. ÊµãËØïÂêëÈáèÊêúÁ¥¢
        console.log('üîç ÊµãËØïÂêëÈáèÊêúÁ¥¢...');
        const searchQueries = [
            'Áî®Êà∑ÁôªÂΩïÂäüËÉΩ',
            'Êï∞ÊçÆÂ∫ìÊìç‰Ωú',
            'REST API',
            'ÂâçÁ´ØÁïåÈù¢'
        ];

        for (const query of searchQueries) {
            console.log(`\nÊêúÁ¥¢Êü•ËØ¢: "${query}"`);
            const queryEmbedding = (await embeddingService.getEmbeddings([query]))[0];
            
            const searchResults = vectorDB.search(collectionName, queryEmbedding, { topK: 3 });
            
            console.log('ÊêúÁ¥¢ÁªìÊûú:');
            searchResults.forEach((result, index) => {
                const doc = result.document;
                const score = (result.score * 100).toFixed(2);
                console.log(`  ${index + 1}. ${doc.metadata.nodeId} (Áõ∏‰ººÂ∫¶: ${score}%)`);
                console.log(`     Á±ªÂûã: ${doc.metadata.elementType} | Êñá‰ª∂: ${doc.metadata.fileName}`);
                console.log(`     ÂÜÖÂÆπ: ${doc.content.substring(0, 50)}...`);
            });
        }

        // 4. ÊòæÁ§∫Êï∞ÊçÆÂ∫ìÁªüËÆ°
        console.log('\nüìä ÂêëÈáèÊï∞ÊçÆÂ∫ìÁªüËÆ°:');
        const stats = vectorDB.getStats();
        console.log(`ÊÄªÈõÜÂêàÊï∞: ${stats.totalCollections}`);
        console.log(`ÊÄªÊñáÊ°£Êï∞: ${stats.totalDocuments}`);
        Object.entries(stats.collections).forEach(([name, info]) => {
            console.log(`ÈõÜÂêà "${name}": ${info.documents} ‰∏™ÊñáÊ°£ÔºåÁª¥Â∫¶ ${info.dimension}`);
        });

        // 5. ÁîüÊàêÊµãËØïÊä•Âëä
        console.log('\nüìù ÁîüÊàêÊµãËØïÊä•Âëä...');
        const reportPath = path.join(projectPath, '.huima', 'vectorization-test-report.md');
        const report = generateTestReport(testTexts, searchQueries, stats);
        
        fs.writeFileSync(reportPath, report);
        console.log(`‚úÖ ÊµãËØïÊä•ÂëäÂ∑≤‰øùÂ≠ò: ${reportPath}`);

        console.log('\n‚úÖ ÊâÄÊúâÊµãËØïÈÄöËøáÔºÅÂêëÈáèÂåñÂäüËÉΩÂ∑•‰ΩúÊ≠£Â∏∏„ÄÇ');

    } catch (error) {
        console.error('‚ùå ÊµãËØïÂ§±Ë¥•:', error);
        throw error;
    }
}

/**
 * ÁîüÊàêÊµãËØïÊä•Âëä
 */
function generateTestReport(testTexts, searchQueries, stats) {
    return [
        '# Áü•ËØÜÂõæË∞±ÂêëÈáèÂåñÂäüËÉΩÊµãËØïÊä•Âëä',
        '',
        `**ÊµãËØïÊó∂Èó¥:** ${new Date().toLocaleString()}`,
        `**ÊµãËØïÁéØÂ¢É:** Node.js ${process.version}`,
        '',
        '## ÊµãËØïÊ¶ÇËø∞',
        '',
        'Êú¨Ê¨°ÊµãËØïÈ™åËØÅ‰∫ÜÁü•ËØÜÂõæË∞±ÂêëÈáèÂåñÂäüËÉΩÁöÑ‰ª•‰∏ãÊñπÈù¢Ôºö',
        '- Embedding ÂêëÈáèÁîüÊàê',
        '- ÂêëÈáèÊï∞ÊçÆÂ∫ìÂ≠òÂÇ®',
        '- ÂêëÈáèÁõ∏‰ººÊÄßÊêúÁ¥¢',
        '- Áü•ËØÜÂõæË∞±ËäÇÁÇπÂêëÈáèÂåñ',
        '',
        '## ÊµãËØïÊï∞ÊçÆ',
        '',
        '### ÊµãËØïÊñáÊú¨',
        '',
        ...testTexts.map((text, index) => `${index + 1}. ${text}`),
        '',
        '### ÊêúÁ¥¢Êü•ËØ¢',
        '',
        ...searchQueries.map((query, index) => `${index + 1}. ${query}`),
        '',
        '## Êï∞ÊçÆÂ∫ìÁªüËÆ°',
        '',
        `- ÊÄªÈõÜÂêàÊï∞: ${stats.totalCollections}`,
        `- ÊÄªÊñáÊ°£Êï∞: ${stats.totalDocuments}`,
        '',
        '### ÈõÜÂêàËØ¶ÊÉÖ',
        '',
        ...Object.entries(stats.collections).map(([name, info]) => 
            `- **${name}**: ${info.documents} ‰∏™ÊñáÊ°£ÔºåÁª¥Â∫¶ ${info.dimension}`
        ),
        '',
        '## ÊµãËØïÁªìÊûú',
        '',
        '‚úÖ **ÊâÄÊúâÊµãËØïÈÄöËøá**',
        '',
        '- Embedding ÊúçÂä°Ê≠£Â∏∏Â∑•‰Ωú',
        '- ÂêëÈáèÊï∞ÊçÆÂ∫ìÂàõÂª∫ÂíåÊèíÂÖ•ÂäüËÉΩÊ≠£Â∏∏',
        '- ÂêëÈáèÊêúÁ¥¢ËøîÂõûÂêàÁêÜÁöÑÁõ∏‰ººÂ∫¶ÁªìÊûú',
        '- Áü•ËØÜÂõæË∞±ËäÇÁÇπÊàêÂäüÂêëÈáèÂåñÂπ∂Â≠òÂÇ®',
        '',
        '## ÁªìËÆ∫',
        '',
        'Áü•ËØÜÂõæË∞±ÂêëÈáèÂåñÂäüËÉΩÂ∑≤ÊàêÂäüÂÆûÁé∞ÔºåÂèØ‰ª•Âú® VS Code Êèí‰ª∂‰∏≠Ê≠£Â∏∏‰ΩøÁî®„ÄÇ',
        'Âª∫ËÆÆÂú®ÂÆûÈôÖ‰ΩøÁî®‰∏≠Ôºö',
        '',
        '1. ÈÖçÁΩÆÁúüÂÆûÁöÑ Embedding API ÊúçÂä°',
        '2. Ê†πÊçÆÈ°πÁõÆÂ§ßÂ∞èË∞ÉÊï¥ÊâπÂ§ÑÁêÜÂèÇÊï∞',
        '3. ÂÆöÊúüÊ∏ÖÁêÜÂíåÊõ¥Êñ∞ÂêëÈáèÊï∞ÊçÆÂ∫ì',
        '4. ÁõëÊéßÂêëÈáèÂåñÊÄßËÉΩÂíåÊêúÁ¥¢Ë¥®Èáè',
        ''
    ].join('\n');
}

/**
 * ËøêË°åÊµãËØï
 */
async function runTests() {
    try {
        await testVectorization();
        console.log('\nüéâ ÂêëÈáèÂåñÂäüËÉΩÊµãËØïÂÆåÊàêÔºÅ');
        console.log('üìã Êü•ÁúãÊµãËØïÊä•Âëä: .huima/vectorization-test-report.md');
        console.log('üìÅ Êü•ÁúãÂêëÈáèÊï∞ÊçÆÂ∫ì: .huima/test-vector-db.json');
    } catch (error) {
        console.error('\nüí• ÊµãËØïÂ§±Ë¥•:', error);
        process.exit(1);
    }
}

// ÊâßË°åÊµãËØï
if (require.main === module) {
    runTests();
}

module.exports = { testVectorization, SimpleVectorDB, SimpleEmbeddingService };